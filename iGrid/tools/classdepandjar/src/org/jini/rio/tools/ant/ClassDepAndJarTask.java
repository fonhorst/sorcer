/*
 * Copyright 2005 Sun Microsystems, Inc.
 * Copyright 2005 GigaSpaces, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jini.rio.tools.ant;

import com.sun.jini.tool.build.ClassDepJarFileFactory;
import com.sun.jini.tool.build.jar.JarElement;
import com.sun.jini.tool.build.jar.JarElementCollator;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.*;

import java.io.*;
import java.util.*;
import java.util.jar.Attributes;
import java.util.jar.JarEntry;
import java.util.jar.Manifest;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/**
 * <code>ClassDepAndJarTask</code> is an Ant Task that will create a jar file from
 * the list of classes generated by the <code>ClassDep</code> tool that is part 
 * of the Jini[tm] Technology SDK. In particular it:
 * <OL>
 * <LI>Searches and <B>extracts</B> classes directly from jar files that are
 * specified in the classpath attribute. Thus it is not necessary to unjar 
 * libraries in order to include elements (classes). 
 * <LI>Creates a Jar file directly; it is <B>not</B> an extension of the Ant Jar
 * task. (See Limitations below.)
 * <LI>Additional elements can be included in the jar file by using nested Fileset
 * elements.
 * </OL>
 *<P>
 * For details on how <code>ClassDep</code> works and the meaning and usage 
 * of its parameters, see its documentation.
 * <P>
 * The following table shows the <code>ClassDepAndJarTask</code>  attributes 
 * and their corresponding <code>ClassDep</code>
 * parameters.
 *<CENTER>
 * <TABLE BORDER="1" WIDTH="66%">
 * <TR>
 * <TH>Attribute</TH>
 * <TH>Parameter
 * <TH>Comment
 * </TR><TR>
 * <TD>classpath<TD>-cp
 * </TR><TR>
 * <TD>in<TD>-in
 * <TR>
 * <TD>out<TD>-out
 * <TR>
 * <TD>files<TD>-files
 * <TR>
 * <TD>edges<TD>-edges
 * <TR>
 * <TD>outer<TD>-outer
 *<TR>
 * <TD>hide<TD>-hide
 *<TR>
 * <TD>prune<TD>-prune
 * <TR>
 * <TD>show<TD>-show
 *<TR>
 * <TD>skip<TD>-skip
 *<TR>
 * <TD>tell<TD>-tell
 *<TR>
 *<TD>topclass<TD>class
 *<TR>
 *<TD>manifest
 *<TR> 
 *<TD>jarfile<TD><TD>Required
 *<TR>
 *--
 *<TR> 
 *<TD>preferredlist<TD><TD>Optional, indicates the input file which will be use 
 *to create the META-INF/PREFERRED.LIST manifest entry
 *<TR>
 *--
 *<TD>debug<TD><TD>Set ="true" for additional information
 * </TABLE>
 * </CENTER>
 * <P>
 * Elements:
 * <P>
 * <code>ClassDepAndJar</code> supports Ant fileset's as elements. Use one or more
 * of these elements to specify files, other than 
 * those generated by <code>ClassDep</code>, that should be added
 * to the jarfile - for example, GIF files, etc. See the Ant documentation for
 * a description of Filesets.
 * <P>
 * <P>
 * Limitations: 
 * <OL>
 * <LI>Because this Task does not extend JarTask you can not
 * use all of the various attributes
 * that are associated with the the Jar Ant Task.
 * <LI>Jar files are always recreated - they are never updated.
 * </OL>
 * <P>
 * Usage:
 *<P>
 *To run properly, the tools.jar file in the Jini technology library must be 
 *reachable by Ant. This is where the <code>ClassDep</code> is stored. 
 * This can easily be done by adding it's directory (usually jini2_0_002/lib)
 * to the classpath of the
 *Ant program.
 * <P>
 * The following must be included in your build file in order to use the
 * ClassDepAndJarTask. The classpath attribute needs to point where the 
 * ClassDepAndJarTask class is located. Alternatively, the task can be 
 * "installed" as an Ant Task; 
 * please refer to the Ant documentation for instructions.
 * <PRE>
   &lt;taskdef name="classdepandjar" 
         classname="org.jini.rio.tools.ant.ClassDepAndJarTask"
         classpath="directory/classdepandjar.jar " /&gt;
* </PRE>
 * <P>
 * The following two targets illustrate how to use the ClassDepAndJar task. The
 * hello.jar target specifies a manifest. The hello-dl.jar target specifies
 * additional elements to add to the jarfile - a gif file, for example.
 * <FONT SIZE="-1">
 * <PRE>
   &lt;target name="hello.jar" depends="rmics" &gt;
    &lt;classdepandjar jarfile="${lib}/hello.jar" files="true" 
         manifest="${src}/org/jini/project/example/jade/serviceimpl/example/hello.mf" &gt;
    &lt;classpath refid="project.path" /&gt;
    &lt;in name="net.jini" /&gt;
    &lt;in name="org.jini" /&gt;
    &lt;in name="com.sun.jini" /&gt;
    &lt;topclass name="org.jini.project.example.jade.serviceimpl.example.StartHelloService" /&gt;
    &lt;topclass name="org.jini.project.example.jade.serviceimpl.example.HelloImpl_Stub" /&gt;
    &lt;topclass name="net.jini.lookup.JoinManager" /&gt;
    &lt;/classdepandjar&gt;
  &lt;/target&gt;

  &lt;target name="hello-dl.jar" depends="rmics" &gt;
    &lt;classdepandjar jarfile="${lib}/hello-dl.jar" files="true" &gt;
    &lt;classpath refid="project.path" /&gt;
    &lt;in name="net.jini" /&gt;
    &lt;in name="org.jini" /&gt;
    &lt;in name="com.sun.jini" /&gt;
    &lt;topclass name="org.jini.project.example.jade.service.example.Hello" /&gt;
    &lt;topclass name="org.jini.project.example.jade.serviceimpl.example.HelloImpl_Stub" /&gt;
    &lt;topclass name="net.jini.lookup.entry.Name" /&gt;
    &lt;topclass name="net.jini.lookup.entry.ServiceInfo" /&gt;
    &lt;topclass name="net.jini.lookup.entry.UIDescriptor" /&gt;
      &lt;fileset dir="${src}"
          includes="org/jini/project/example/jade/action/example/hello*.gif" /&gt;
      &lt;fileset dir="${classes}"
         includes="org/jini/project/example/jade/action/example/*Hello*.class" /&gt;
    &lt;/classdepandjar&gt;
  &lt;/target&gt;

* </PRE>
 *<P>
 *Acknowledgements:
 *<P>
 *Steven Harris wrote the class that does all the work: <code>ClassDepJarFactory</code>.
 *His code utilizes some Jar support classes developed by Jimmy Torres.
 *<BR>
 *Jim Clarke wrote a ClassDepTask that served as a guide for writing this Ant
 * Task. The author has used his ClassDepTask.
 *<P>
 * @author Peter C. Marks (Assembler)
 * @version 1.0
 */
public class ClassDepAndJarTask extends Task {
    ClassLoader loader;
    private Set entrySet;      
    /** Storage */
    private Path compileClasspath = null;
    /** A task attribute */
    private boolean debug;
    /* Each attribute below corresponds to a ClassDep parameter. See the
     * javadoc for ClassDep for a fuller explanation.*/
    /** Cause output to be in filename format. */
    private boolean files;
    /** Include "edges" classes. */
    private boolean edges;
    /** Suppresses the display of classes */
    private ArrayList hide = new ArrayList();
    /** Namespace of classes to include */
    private ArrayList in = new ArrayList();
    /** The jarfile to create or update? */
    private File jarfile;
    /** Manifest file or null permitted */
    private Manifest manifest = null;
    /** Namespace of classes not to include */
    private ArrayList out = new ArrayList();
    /** Causes the parent of a static inner class to be included */
    private boolean outer;
    /** Skip over the specified namespace of classes */
    private ArrayList prune = new ArrayList();
    /** Display only a subset of total dependency set. */
    private ArrayList show = new ArrayList();
    /** Classes to ignore. */
    private ArrayList skip = new ArrayList();
    /** Debugging: classes in the classpath that use this attribute value */
    private ArrayList tell = new ArrayList();
    /** Elements - class names and/or directories to be included */
    private ArrayList topclass = new ArrayList();
    /** To add embedded filesets */
    private ArrayList filesets = new ArrayList();  // List<FileSet>
    /* PreferredList property */
    private File preferredList;
    static final String PREFERRED_LIST_ENTRY = "META-INF/PREFERRED.LIST";

    /** 
     * Creates a new <code>ClassDepAndJarTask</code> 
     */
    public ClassDepAndJarTask() {
    }    

    /* The attributes' methods:
     * Ant requires that attributes have a setter method, e.g. setXXXX().
     * If the task has nested elements then there must be a creation
     * method: createXXXX() or an adder method: addXXXX(). More details
     * can be found in the Ant documentation.
     *
     * The various getters are for constructing an argument list that
     * will used in the call to ClassDepJarFileFactory.*/

    /**
     * Set the classpath to be used for this compilation
     * 
     * @param classpath The classpath to store.
     */
    public void setClasspath(Path classpath) {
        if(compileClasspath == null) {
            compileClasspath = classpath;
            log("setClasspath::classpath was null, now is= "+classpath.toString(), 
                Project.MSG_DEBUG);
        } else {
            compileClasspath.append(classpath);
            log("setClasspath::appending classpath = "+classpath.toString(), 
                Project.MSG_DEBUG);
        }
    }
    /**
     * Maybe create a nested classpath element
     * 
     * @return The classpath
     */
    public Path createClasspath() {
        if(compileClasspath == null) {
            compileClasspath = new Path(getProject());            
            log("createClasspath::new classpath = "+compileClasspath.toString(), 
                Project.MSG_DEBUG);
        } else {
            log("createClasspath::classpath = "+compileClasspath.toString(), 
                Project.MSG_DEBUG);
        }
        return compileClasspath.createPath();
    }
    
    /**
     * Adds a reference to a classpath defined elsewhere.
     * 
     * @param ref An Ant reference to a path
     */
    public void setClasspathRef(Reference ref) {
        log("createClasspathRef:: = "+ref.toString(), Project.MSG_DEBUG);
        createClasspath().setRefid(ref);
    }

    /**
     * Getter for classpath.
     * 
     * @return The stored classpath
     */
    protected Path getClasspath() {        
        Path classpath = new Path(getProject());        
        if(classpath==null)
            log("getClasspath:: = classpath is null", Project.MSG_DEBUG);
        else
            log("getClasspath:: = "+classpath.toString(), Project.MSG_DEBUG);
        // add our classpath to the mix.
        if(compileClasspath != null) {
            classpath.addExisting(compileClasspath);
        }
        // add the system classpath
        classpath.addExisting(Path.systemClasspath);
        return classpath;
    }

    /**
     * Set the edges attribute
     * 
     * @param edges classes outside of namespaces
     */
    public void setEdges(boolean edges) {
        this.edges = edges;
        log("setEdges::edges flag = "+edges, Project.MSG_DEBUG);
    }

    /**
     * Getter for edges.
     * 
     * @return if edges has been specified
     */
    public boolean isEdges() {
        return edges;
    }

    /**
     * Set the files attribute
     * 
     * @param files true or false
     */
    public void setFiles(boolean files) {
        this.files = files;
        log("setFiles::files flag = "+files, Project.MSG_DEBUG);
    }

    /**
     * Getter for files
     * 
     * @return true or false
     */
    public boolean isFiles() {
        return files;
    }

    /**
     * Creator for hide element.
     */
    public Argument createHide() {
        Argument argument = new Argument();
        hide.add(argument);
        log("createHide::hide = "+hide, Project.MSG_DEBUG);
        return argument;
    }

    /**
     * Set the hide element
     */
    public void setHide(String arg) {
        StringTokenizer st = new StringTokenizer(arg, ", \t\n\r\f");
        while(st.hasMoreTokens()) {
            hide.add(new Argument(st.nextToken()));
        }
        log("setHide::hide = "+hide, Project.MSG_DEBUG);
    }

    /**
     * Creator for in element.
     */
    public Argument createIn() {
        Argument argument = new Argument();
        in.add(argument);
        log("createIn::in = "+in, Project.MSG_DEBUG);
        return argument;
    }

    /**
     * Set the in element.
     */
    public void setIn(String arg) {
        StringTokenizer st = new StringTokenizer(arg, ", \t\n\r\f");
        while(st.hasMoreTokens()) {
            in.add(new Argument(st.nextToken()));
        }
    }

    /**
     * Set the jarfile attribute
     */
    public void setJarfile(File jarfile) {
        this.jarfile = jarfile;
        try {
           log("setJarfile::jarfile = "+jarfile.getCanonicalPath(), Project.MSG_DEBUG);
        } catch (IOException ioe) {
            log("setJarfile::io exception = "+ioe, Project.MSG_DEBUG);
        }
        /*
        if (!this.manifest.exists())
            throw new BuildException("Manifest file: " + manifest + " does not exist.");
        */
    }

    /**
     * Getter for the jarfile attribute
     */
    public File getJarfile() {
        return jarfile;
    }

    /**
     * Set the manifest attribute
     */
    public void setManifest(File manifestFile) {
        try {
            FileInputStream fis = new FileInputStream(manifestFile);
            this.manifest = new Manifest(fis);            
            log("setManifest::manifestFile = "+manifestFile.getCanonicalPath(), Project.MSG_DEBUG);  
        } catch(FileNotFoundException fnfe) {
            throw new BuildException("Manifest file:" + manifestFile + " not found");
        } catch(IOException ioe) {
            throw new BuildException("Manifest file: " + manifestFile + " IOException");
        }      
    }

    /**
     * Getter for the manifest attribute
     */
    public Manifest getManifest() {
        return manifest;
    }

    public void setPreferredlist(File file) {        
        preferredList = file;
    }    
    
    /**
     * Creator for out element.
     */
    public Argument createOut() {
        Argument argument = new Argument();
        out.add(argument);
        log("createOut::out = "+out, Project.MSG_DEBUG);   
        return argument;
    }

    /**
     * Set the out element.
     */
    public void setOut(String arg) {
        StringTokenizer st = new StringTokenizer(arg, ", \t\n\r\f");
        while(st.hasMoreTokens()) {
            out.add(new Argument(st.nextToken()));
        }
        log("setOut::out = "+out, Project.MSG_DEBUG);   
    }

    /**
     * Set the outer attribute
     */
    public void setOuter(boolean outer) {
        this.outer = outer;
    }

    /**
     * Getter for outer.
     */
    public boolean isOuter() {
        return outer;
    }

    /**
     * Creator for prune element.
     */
    public Argument createPrune() {
        Argument argument = new Argument();
        prune.add(argument);
        log("createPrune::prune = "+prune, Project.MSG_DEBUG);   
        return argument;
    }

    /**
     * Set the prune element.
     */
    public void setPrune(String arg) {
        StringTokenizer st = new StringTokenizer(arg, ", \t\n\r\f");
        while(st.hasMoreTokens()) {
            prune.add(new Argument(st.nextToken()));
        }
        log("setPrune::prune = "+prune, Project.MSG_DEBUG);   
    }

    /**
     * Creator for show element.
     */
    public Argument createShow() {
        Argument argument = new Argument();
        show.add(argument);
        log("createShow::show = "+show, Project.MSG_DEBUG);
        return argument;
    }

    /**
     * Set the show element.
     */
    public void setShow(String arg) {
        StringTokenizer st = new StringTokenizer(arg, ", \t\n\r\f");
        while(st.hasMoreTokens()) {
            show.add(new Argument(st.nextToken()));
        }
        log("setShow::show = "+show, Project.MSG_DEBUG);
    }

    /**
     * Creator for skip element.
     */
    public Argument createSkip() {
        Argument argument = new Argument();
        skip.add(argument);
        log("createSkip::skip = "+skip, Project.MSG_DEBUG);
        return argument;
    }

    /**
     * Set the skip element.
     */
    public void setSkip(String arg) {
        StringTokenizer st = new StringTokenizer(arg, ", \t\n\r\f");
        while(st.hasMoreTokens()) {
            skip.add(new Argument(st.nextToken()));
        }
        log("setSkip::skip = "+skip, Project.MSG_DEBUG);
    }

    /**
     * Creator for tell element.
     */
    public Argument createTell() {
        Argument argument = new Argument();
        tell.add(argument);
        log("createTell::tell = "+tell, Project.MSG_VERBOSE);
        return argument;
    }

    /**
     * Set the tell element.
     */
    public void setTell(String arg) {
        StringTokenizer st = new StringTokenizer(arg, ", \t\n\r\f");
        while(st.hasMoreTokens()) {
            tell.add(new Argument(st.nextToken()));
        }
        log("setTell::tell = "+tell, Project.MSG_VERBOSE);
    }

    /**
     * Creator for topclass element.
     */
    public Argument createTopclass() {
        Argument argument = new Argument();
        topclass.add(argument);
        log("createTopclass::topclass = "+topclass, Project.MSG_VERBOSE);
        return argument;
    }

    /**
     * Set the topclass element.
     * 
     * @param arg Name of a class
     */
    public void setTopclass(String arg) {
        StringTokenizer st = new StringTokenizer(arg, ", \t\n\r\f");
        while(st.hasMoreTokens()) {
            topclass.add(new Argument(st.nextToken()));
        }
        log("setTopclass::topclass = "+topclass, Project.MSG_VERBOSE);
    }
    
    /**
     * Append another fileset
     * 
     * @param fs Additional fileset
     */
    public void addFileset(FileSet fs) {
        filesets.add(fs);
    }

    /**
     * Append another zipfileset
     * 
     * @param fs Additional zipfileset
     */
    public void addZipfileset(ZipFileSet fs) {
        filesets.add(fs);
    }
    
    /**
     * add a Metainf fileset
     *
     * @param fs the inf fileset
     */
    public void addMetainf(FileSet fs) {
        //fs.setPrefix("META-INF/");
        filesets.add(fs);
    }
    
    public void addConfiguredManifest(org.apache.tools.ant.taskdefs.Manifest m) {
        try {
            if(m.getManifestVersion() == null) {
                org.apache.tools.ant.taskdefs.Manifest.Attribute attr =
                    new org.apache.tools.ant.taskdefs.Manifest.Attribute(
                        org.apache.tools.ant.taskdefs.Manifest.ATTRIBUTE_MANIFEST_VERSION, 
                        org.apache.tools.ant.taskdefs.Manifest.DEFAULT_MANIFEST_VERSION);
                m.addConfiguredAttribute(attr);
            }
            StringWriter sw = new StringWriter();
            PrintWriter writer = new PrintWriter(sw);
            m.write(writer);
            writer.close();
            InputStream is = new ByteArrayInputStream(sw.getBuffer().toString().getBytes());
            Manifest man = new Manifest(is);
            if(this.manifest == null) {
                this.manifest = man;
            } else {
                merge(man);
            }
        } catch(Exception ex) {
            throw new BuildException("Failed to read manifest entry", ex);
        }
    }
    
    private void merge(Manifest m) {
        log("Merging manifest", Project.MSG_VERBOSE);
        Attributes mainAttributes = m.getMainAttributes();
        Attributes thisAttributes = this.manifest.getMainAttributes();
        mergeAttributes("", thisAttributes, mainAttributes);        
        
        Map entries = m.getEntries();
        Map thisEntries = this.manifest.getEntries();
        Iterator iter = entries.keySet().iterator();
        while(iter.hasNext()) {
            String key = (String)iter.next();
            Attributes attrs = (Attributes)entries.get(key);
            Attributes thisAttrs = (Attributes)thisEntries.get(key);
            mergeAttributes(key, thisAttrs, attrs);
        }
    }

    private void mergeAttributes(String key, Attributes current, 
                                 Attributes newAttributes) {
        if(current == null) {
            if(key.equals(""))
                throw new BuildException("Current attributes cannot "+
                                         "be null for MAIN section");
            log("Adding entry: " + key + " = " + newAttributes, Project.MSG_VERBOSE);
            this.manifest.getEntries().put(key, newAttributes);
        }else {
            Iterator iiter = newAttributes.keySet().iterator();
            while(iiter.hasNext()) {
                Attributes.Name name = (Attributes.Name)iiter.next();
                if(name.equals(Attributes.Name.CLASS_PATH)) {

                    String newClassPath = newAttributes.getValue(name);

                    String classpath = current.getValue(name);
                    if(classpath == null) {
                        log("Adding classpath: " + newClassPath, Project.MSG_VERBOSE);
                        current.put(name, newClassPath);
                    } else {

                        classpath += " " + newClassPath;
                        log("Merged classpath = " + classpath, Project.MSG_VERBOSE);
                        current.put(name, classpath);
                    }
                }else {
                    // new value always trumps the old value
                    String value = newAttributes.getValue(name);
                    log("Setting attribute: " + name + " = " + value, 
                        Project.MSG_VERBOSE);
                    current.put(name,  value);
                }
            }
        }
    }
    
    /**
     * Transform all the Ant task attributes and elements into an
     * array of Strings that we can feed to <CODE>ClassDep</CODE>
     * 
     * @return Ant attributes in array format
     */
    protected String[] getClassDepArgs() {
        ArrayList argList = new ArrayList();
        Path classpath = getClasspath();
        Iterator iter;

        if(classpath != null) {
            argList.add("-cp");
            argList.add(classpath.toString());
        }
        if(edges) {
            argList.add("-edges");
        }
        if(files) {
            argList.add("-files");
        }
        for(iter = hide.iterator(); iter.hasNext();) {
            argList.add("-hide");
            argList.add(((Argument)iter.next()).getName());
        }
        for(iter = in.iterator(); iter.hasNext();) {
            argList.add("-in");
            argList.add(((Argument)iter.next()).getName());
        }
        for(iter = out.iterator(); iter.hasNext();) {
            argList.add("-out");
            argList.add(((Argument)iter.next()).getName());
        }
        if(outer) {
            argList.add("-outer");
        }
        for(iter = prune.iterator(); iter.hasNext();) {
            argList.add("-prune");
            argList.add(((Argument)iter.next()).getName());
        }
        for(iter = show.iterator(); iter.hasNext();) {
            argList.add("-show");
            argList.add(((Argument)iter.next()).getName());
        }
        for(iter = skip.iterator(); iter.hasNext();) {
            argList.add("-skip");
            argList.add(((Argument)iter.next()).getName());
        }
        for(iter = tell.iterator(); iter.hasNext();) {
            argList.add("-tell");
            argList.add(((Argument)iter.next()).getName());
        }
        for(iter = topclass.iterator(); iter.hasNext();) {
            String arg = ((Argument)iter.next()).getName();
            if(File.separatorChar == '/') {
                if(arg.indexOf('\\') >= 0) {
                    arg = arg.replace('\\', File.separatorChar);
                }
            } else if(File.separatorChar == '\\') {
                if(arg.indexOf('/') >= 0) {
                    arg = arg.replace('/', File.separatorChar);
                }
            }
            argList.add(arg);
        }


        return(String[])argList.toArray(new String[argList.size()]);
    }

    /**
     * Getter for debug attribute
     * 
     * @return To debug or not to debug
     */
    public boolean isDebug() {
        return debug;
    }

    /**
     * Setter for debug attribute
     * 
     * @param debug true or false
     */
    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    /** 
     * Return a text description of this Task.
     * 
     * @return Description of this Task.
     */
    public java.lang.String getDescription() {
        return "Create a Jar file based on the output of ClassDep";
    }
    
    private String[] replaceArgsWithAbsFilePath(String baseName, String[] classDepArgs) {
        String [] newArgs;
        newArgs = classDepArgs;
        String sepChar = "."+File.separatorChar;
        for (int i = 0; i < classDepArgs.length; i++) {
            log("old arg is: " + classDepArgs[i], Project.MSG_VERBOSE);
            int index = classDepArgs[i].indexOf(sepChar);
            if (index != -1) {
                newArgs[i] = classDepArgs[i].substring(0, index) 
                           + baseName 
                           + File.separatorChar 
                           + classDepArgs[i].substring(index + sepChar.length(),  
                                                       classDepArgs[i].length());
            }
            log("new arg is: " + newArgs[i], Project.MSG_VERBOSE);
        }
        return newArgs;
    }

    /**
     * Ant calls this execute() method to have the task do its thing.
     * Gather arguments given to us by Ant and have a 
     * <code>ClassDepJarFileFactory</code>
     * run <code>ClassDep</code> and then create a jar file. Finally, add any
     * files specified via fileset elements.
     *
     * @throws BuildException Thrown when an error occurs within the task.
     */
    public void execute() throws BuildException {
        try {
            // Sine qua non
            if(getJarfile() == null) {
                throw new BuildException("No jarfile specified");
            }
            log("jar file is: " + getJarfile().getCanonicalPath(), 
                Project.MSG_VERBOSE);
            Project proj = getProject();
            File current = proj.getBaseDir();
            
            log("current directory is: " + current.getCanonicalPath(), 
                Project.MSG_VERBOSE);

            // Turn the attributes and elements into an array of arguments
            String[] classDepArgs = getClassDepArgs();
             
            classDepArgs = replaceArgsWithAbsFilePath(current.getCanonicalPath(), 
                                                      classDepArgs);
            
            log("class dep args are: ", Project.MSG_VERBOSE);
            for (int i = 0; i < classDepArgs.length; i++)
            log("\n\t"+classDepArgs[i], Project.MSG_VERBOSE);
            
            // Create a JarElementCollator that will be used by a
            // ClassDepJarFileFactory. The collator will create a jarfile
            // and provide methods to add jar elements
            String jarFilename = getJarfile().toString();
            log("jarfile name = " + jarFilename, Project.MSG_VERBOSE);
            JarElementCollator jarElementCollator = 
                new JarElementCollator(jarFilename, getManifest());
            /* Add the preferred list if not null */
            if(preferredList!=null) {               
                jarElementCollator.addJarElement(
                    new JarElement(new JarEntry(PREFERRED_LIST_ENTRY),
                                   (InputStream)new FileInputStream(
                                                   preferredList.getAbsolutePath())));               
            }
            ClassDepJarFileFactory classDepJarFileFactory = 
                new ClassDepJarFileFactory(jarElementCollator, 
                                           classDepArgs, 
                                           this);

            // Have the factory do the ClassDep and create the jar file
            String[] requiredClasses = classDepJarFileFactory.getRequiredClasses();
            log("number of required classes = " + requiredClasses.length, 
                Project.MSG_VERBOSE);
            if(requiredClasses.length > 0) {
                for(int i = 0; i < requiredClasses.length; i++) {
                    log("classdep=> " + requiredClasses[i], Project.MSG_VERBOSE);
                }
            }
            entrySet = classDepJarFileFactory.createJarFile(requiredClasses);

            // Add additional JarElements such as other class files, GIF files,
            // etc. Run through all the filesets and get the names of the files to
            // include directly in the jar file.
            Iterator it = filesets.iterator();
            while(it.hasNext()) {
                FileSet fs = (FileSet) it.next();
                DirectoryScanner ds = fs.getDirectoryScanner(getProject());
                if(fs instanceof ZipFileSet) {
                    log("Adding ZipFileSet...", Project.MSG_VERBOSE);
                    addZipEntries((ZipFileSet)fs, ds, jarElementCollator);
                } else {
                    log("Adding FileSet...", Project.MSG_VERBOSE);
                    addFiles(fs, ds, jarElementCollator);
                }
            }

            // Close the collator and the jarfile
            jarElementCollator.closeJar();

        } catch(Exception e) {
            throw new BuildException(e.getMessage());
        }
    }

    protected void addZipEntries(ZipFileSet fs, 
                                 DirectoryScanner ds, 
                                 JarElementCollator jarElementCollator) {
        File basedir = ds.getBasedir();
        String prefix = fs.getPrefix(getProject());
        String fullpath = fs.getFullpath(getProject());
        if(prefix.length() > 0 && fullpath.length() > 0)
            throw new BuildException("Both prefix and fullpath attributes may not "+
                                     "be set on the same fileset.");

        if(prefix.length() > 0
           && !prefix.endsWith("/")
           && !prefix.endsWith("\\")) {
            prefix += "/";
        }

        // Need to manually add either fullpath's parent directory, or
        // the prefix directory, to the archive.
        if(prefix.length() > 0) {
            jarDir(jarElementCollator, prefix, basedir);
        }

        ZipScanner zipScanner = (ZipScanner) ds;
        File zipSrc = fs.getSrc(getProject());

        ZipEntry entry;
        java.util.zip.ZipEntry origEntry;
        ZipInputStream in = null;
        try {
            in = new ZipInputStream(new FileInputStream(zipSrc));

            while((origEntry = in.getNextEntry()) != null) {
                entry = new ZipEntry(origEntry);
                String vPath = entry.getName();
                if(zipScanner.match(vPath)) {
                    if(fullpath.length() > 0) {
                        jarFile(in, 
                                jarElementCollator, 
                                fullpath, 
                                entry.getTime(), 
                                basedir);
                    } else {
                        if(!entry.isDirectory()) {
                            jarFile(in, 
                                    jarElementCollator, 
                                    prefix+vPath, 
                                    entry.getTime(), 
                                    basedir);
                        }
                    }
                }
            }
        } catch(Exception ex) {
            throw new BuildException("Failed to read zip file: " + zipSrc , ex);
        } finally {
            if(in != null) {
                try {
                    in.close();
                } catch(Exception ignore) {
                }
            }
        }
    }

    protected void addFiles(FileSet fs, 
                            DirectoryScanner ds, 
                            JarElementCollator jarElementCollator) {
        try {
            File basedir = ds.getBasedir();
            String[] files = ds.getIncludedFiles();
            // process them...
            for(int i = 0; i < files.length; i++) {
                // Note that we create a JarElement using two names:
                //  1. The name of the element and
                //  2. The place where you can find its bits (hence the use
                //     of the basedir.
                String filename = files[i].replace('\\','/'); // for Windows files
                JarElement je = 
                    new JarElement(filename, basedir + File.separator + files[i]);
                if(!entrySet.contains(je.getJarEntry().getName())) {
                    jarElementCollator.addJarElement(je);
                    
                    log("fileset=> " + basedir + File.separator + files[i], 
                        Project.MSG_VERBOSE);
                    entrySet.add(je.getJarEntry().getName());
                }
            }
        } catch(Exception e) {
            throw new BuildException(e.getMessage());
        }
    }

    protected void jarDir(JarElementCollator jarElementCollator, 
                          String vPath,  
                          File basedir) {
        try {
            String filename = vPath.replace('\\','/');
            JarElement je = 
                new JarElement(filename, basedir + File.separator + vPath);
            if(!entrySet.contains(je.getJarEntry().getName())) {
                jarElementCollator.addJarElement(je);
                log("fileset(dir)=> " + vPath, Project.MSG_VERBOSE);
                entrySet.add(je.getJarEntry().getName());
            }
        } catch(Exception e) {
            throw new BuildException("failed to build jar dir", e);
        }
    }

    protected void jarFile(InputStream in, 
                           JarElementCollator jarElementCollator, 
                           String vPath, 
                           long lastModified,  
                           File basedir) {
        try {
            String filename = vPath.replace('\\','/');
            JarElement je = new JarElement();
            je.setInputStream(in);
            je.setJarEntry(filename);
            je.getJarEntry().setTime(lastModified);
            if(!entrySet.contains(je.getJarEntry().getName())) {
                jarElementCollator.addJarElement(je);
                log("zipfileset=> " + vPath, Project.MSG_VERBOSE);
                entrySet.add(je.getJarEntry().getName());
            }
        } catch(Exception ex) {
            throw new BuildException("failed to add from jar", ex);
        }
    }
}
